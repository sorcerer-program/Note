---
date: 2024-11-01
tags:
  - leetcode76
  - 数组
  - 算法
  - 双指针
---
# 滑动窗口(最小覆盖子串)
## 题目
![[leetcode76.png]]
![[leetcode76.jpg]]
## 理解
> 窗口中频率达到要求的字母数量=t中的字母种量，就表明我们找到一个子串，但不一定是最小子串。`required == formed`。用两个数组来记录频率，巧妙地将ASCII码当做下标，使得字母和频率一一对应。`int tFreq[128] = {0}, windowFreq[128] = {0};`。这个过程是**扩展右边界**的过程。

> 当找到一个子串时，我们就应该寻找下一个子串，这个时候就应收缩窗口，移动左边界。顺带长度。收缩之后，有可能减少的那个就是我们需要的那个，我们要检查一下满足的数量`formed`是否减少。这个过程就是**收缩左边界的过程**。

> 我在`left < right`还是`left <= right`这一点犯了一些迷糊。答案显然是后者，因为当`left == right`的时候，说明这个字符串只有一个字母，难道只有一个字母就不去检查更新了吗，肯定不对啊。随意这个时候还是应当进入循环，所以选择`<=`。
## 解答
```c
char* minWindow(char* s, char* t){
	int left = 0, right = 0;
	int window_freq[128] = {0}, t_freq[128] = {0};
	int required = 0, formed = 0, start = 0, min_len = INT_MAX;

	// 统计t中每个字符出现的次数
	for(int i = 0; t[i] != '\0'; i++){
		if(t_freq[t[i]] == 0) required++;
		t_freq[t[i]]++;
	}

	while(right < strlen(s)){
		char ch = s[right];
		whidow_freq[ch]++;
		if(t_freq[ch] > 0 && window_freq[ch] == t_freq[ch]) formed++;

		while(left <= right && formed == required){
			if(right-left+1 < min_len){
				min_len = right - left + 1;
				start = left;
			}

			// 移除左边字符并且更新窗口状态
			char left_char = s[left];
			widow_freq[left_char]--;
			if(t_freqp[left_char] > 0 
			&& window_freq[letf_char] < t_freq[letf_char]) formed--;
			left++;
		}
		right++;
	}
	if(min_len == INT_MAX) return "";
	char* result = (char*)malloc(sizeof(char)*(min_len+1));
	result[min_len] = '\0';
	return result;
}
```

这个问题感觉很难，但本质上是滑动窗口，对比分析一下基础的滑动窗口[[滑动窗口(长度最小的子数组)]]