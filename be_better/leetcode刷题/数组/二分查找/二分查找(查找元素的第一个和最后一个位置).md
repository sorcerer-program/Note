---
date: 2024-07-21
tags:
  - leetcode34
  - 二分查找
  - 数组
  - 算法
---

# 二分查找(查找元素的第一个和最后一个位置)

## 题目
![[leetcode34.png]]

## 理解关键点

两种方向：

1. 通过基础的二分法找到target然后左右扩散，找到最左和最右(第一步二分，第二步遍历，适用于target重复数量不是特别大)
2. 将  `nums[middle]==target`  的时候不返回，继续收缩(全是二分法，适用于target重复数量很大

​	寻找左边界的时候，`nums[middle]==target`  不能停止，因为左边也	许还有，所以要继续收缩右边界

​	同理，寻找右边界时，找到了相等还应当继续收缩左边界

## 解答

### 解法1

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int findTarget(int* nums,int numsSize,int target){
    int left = 0;
    int right = numsSize;
    while(left < right){
        int middle = (right + left)/2;
        if(target == nums[middle]){
            return middle;
        }else if(target < nums[middle]){
            right = middle;
        }else{
            left = middle + 1;
        }
    }
    return -1;
}
int* findBorder(int* nums,int numsSize,int target,int border,int* result){
    result[0] = border;
    result[1] = border;
    int leftBorder = border;
    int rightBorder = border;

    if(border != 0){//需要找左边的情况
        while(leftBorder >= 0){
            if(nums[leftBorder] != target){
                break;
            }
            leftBorder--;
        }
        result[0] = leftBorder + 1;
    }
    if(border != numsSize - 1){//需要找右边的情况
        while(rightBorder < numsSize){
            if(nums[rightBorder] != target){
                break;
            }
            rightBorder++;
        }
        result[1] = rightBorder - 1;
    }
    return result;
}
int* searchRange(int* nums, int numsSize, int target, int* returnSize) {
   * returnSize = 2;
   int* result = (int*)malloc(sizeof(int)*2);
   result[0] = -1;
   result[1] = -1;
   int target0 = findTarget(nums,numsSize,target);
   if(target0 == -1){
        return result;
   }
   return findBorder(nums,numsSize,target,target0,result);
}
```

### 解法2

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int findFirst(int* nums,int numsSize,int target){
    int left = 0;
    int right = numsSize;
    while(left < right){
        int middle = (left + right)/2;
        if(target > nums[middle]){
            left = middle + 1;
        }else{
            right = middle;
        }
    }
    if(left < numsSize && nums[left] == target){
        return left;
    }
    return -1;
}
int findLast(int* nums,int numsSize,int target){
    int left = 0;
    int right = numsSize;
    while(left < right){
        int middle = (right + left)/2;
        if(target < nums[middle]){
            right = middle;
        }else{
            left = middle + 1;
        }
    }
    if(right > 0 && nums[right - 1] == target){
        return right - 1;
    }
    return -1;
}
int* searchRange(int* nums, int numsSize, int target, int* returnSize) {
   *returnSize = 2;
    int* result = (int*)malloc(sizeof(int) * 2);
   result[0] = findFirst(nums,numsSize,target);
   result[1] = findLast(nums,numsSize,target);
   return result;
}
```


对比分析[[二分查找(基础)]]
