---
date: 2024-08-03
tags:
  - 移除元素
  - 双指针
  - 算法
  - 数组
  - leetcode844
---

# 移除元素(比较含退格的字符串)

## 题目

![[leetcode844.png]]

## 理解关键点

> 其实思路都是得到处理后的字符串进行比较，不同点就在于怎样处理字符串

1. 每个字符串两个空间，一个用来遍历判断，一个用来存放处理后的字符

​	如果是退格符，就栈顶弹出；如果是普通字符，就压入栈中

2. 双指针

   在原本的空间基础上进行处理。如果快指针不指向退格符，就将所指字符赋给慢指针指向的空间；如果快指针指向退格符，说明需要将慢指针所指向的内容删除就，慢指针后退，这里有一个易错点就是慢指针退到零了就退不了了，要注意下标不要越界。

## 解答

###  解法1(两个数组空间)

```c
char* build(char* str){
    int n = strlen(str), len = 0;
    char* ret = malloc(sizeof(char) * (n + 1)); //多一个用来存放终止符
    for (int i = 0; i < n; i++){
        if(str[i] != '#'){
            ret[len++] == str[i];
        }else if(len>0){
            len--;
        }
    }
    ret[len] = '\0';
    return ret;
}
bool backspaceCompare(char* s, char* t) {
    return strcmp(build(s),build(t)) == 0;
}
```

### 解法2(双指针,一个空间)

```c
char* build(char* str){
    int fastIndex = 0, slowIndex = 0;
    for(fastIndex; str[fastIndex] != '\0'; fastIndex++){
        if(str[fastIndex] != '#'){
            str[slowIndex++] = str[fastIndex];
        }else if(slowIndex > 0){	//这里的判断条件容易忽略
            slowIndex--;
        }
    }
    str[slowIndex] = '\0';
    return str;
}
bool backspaceCompare(char* s, char* t) {
    return strcmp(build(s), build(t)) == 0;
}
```

对比参照[[移除元素(基础)]]



