# 作业7
## 选择题
1C 2B 3C 4A 5A 6C 7D 8C 9CA 10CB 
## 填空题
1：n-1
2：1   0
3：1
## 综合题
1.![[760611b10901e9a99ff2523341f6874.jpg]]
2.
广度优先：1->2->3->4->5->6->8->7
深度优先：1->2->3->6->4->5->7->8
3.
![[e5202c397375ac9fed854e6fc63beb8.jpg]]
4.
![[e9f54c0df3197298cfc79f32cee1df8.jpg]]

5.
(1) 8->4->2->1->3->6->7->5
(2) 4->5->6->7->NULL

11.
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAXV 100

typedef struct ArcNode {
    int adjvex;
    struct ArcNode *next;
} ArcNode;

typedef struct {
    ArcNode *first;
} VNode;

typedef struct {
    VNode adjlist[MAXV];
    int n;
} ALGraph;

bool visited[MAXV];

void addEdge(ALGraph *G, int u, int v) {
    ArcNode *node = (ArcNode *)malloc(sizeof(ArcNode));
    node->adjvex = v;
    node->next = G->adjlist[u].first;
    G->adjlist[u].first = node;
}

bool DFS(ALGraph *G, int vi, int vj) {
    if (vi == vj) return true;
    visited[vi] = true;
    for (ArcNode *p = G->adjlist[vi].first; p; p = p->next) {
        if (!visited[p->adjvex]) {
            if (DFS(G, p->adjvex, vj)) return true;
        }
    }
    return false;
}

int main() {
    ALGraph G = { .n = 4 };
    addEdge(&G, 0, 1);
    addEdge(&G, 1, 2);
    addEdge(&G, 2, 3);

    for (int i = 0; i < G.n; i++) visited[i] = false;

    int vi = 0, vj = 3;
    if (DFS(&G, vi, vj))
        printf("存在从 %d 到 %d 的路径\n", vi, vj);
    else
        printf("不存在从 %d 到 %d 的路径\n", vi, vj);

    return 0;
}

```
12.
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAXV 100

typedef struct ArcNode {
    int adjvex;
    struct ArcNode *next;
} ArcNode;

typedef struct {
    ArcNode *first;
} VNode;

typedef struct {
    VNode adjlist[MAXV];
    int n;
} ALGraph;

typedef struct {
    int data[MAXV];
    int front, rear;
} Queue;

void initQueue(Queue *q) { q->front = q->rear = 0; }
bool isEmpty(Queue *q) { return q->front == q->rear; }
void enqueue(Queue *q, int x) { q->data[q->rear++] = x; }
int dequeue(Queue *q) { return q->data[q->front++]; }

void addEdge(ALGraph *G, int u, int v) {
    ArcNode *node = (ArcNode *)malloc(sizeof(ArcNode));
    node->adjvex = v;
    node->next = G->adjlist[u].first;
    G->adjlist[u].first = node;
}

bool hasPath_BFS(ALGraph *G, int vi, int vj) {
    bool visited[MAXV] = {false};
    Queue q;
    initQueue(&q);
    enqueue(&q, vi);
    visited[vi] = true;

    while (!isEmpty(&q)) {
        int u = dequeue(&q);
        for (ArcNode *p = G->adjlist[u].first; p; p = p->next) {
            if (!visited[p->adjvex]) {
                if (p->adjvex == vj) return true;
                visited[p->adjvex] = true;
                enqueue(&q, p->adjvex);
            }
        }
    }
    return false;
}

int main() {
    ALGraph G = { .n = 4 };
    addEdge(&G, 0, 1);
    addEdge(&G, 1, 2);
    addEdge(&G, 2, 3);

    int vi = 0, vj = 3;
    if (hasPath_BFS(&G, vi, vj))
        printf("存在从 %d 到 %d 的路径\n", vi, vj);
    else
        printf("不存在从 %d 到 %d 的路径\n", vi, vj);

    return 0;
}

```
20.
```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdbool.h>

#define MAXV 100

typedef struct ArcNode {
    int adjvex;
    int weight;
    struct ArcNode *next;
} ArcNode;

typedef struct {
    ArcNode *first;
} VNode;

typedef struct {
    VNode adjlist[MAXV];
    int n;
} ALGraph;

void addEdge(ALGraph *G, int u, int v, int w) {
    ArcNode *node = (ArcNode *)malloc(sizeof(ArcNode));
    node->adjvex = v;
    node->weight = w;
    node->next = G->adjlist[u].first;
    G->adjlist[u].first = node;
}

void Dijkstra(ALGraph *G, int start, int dist[], int path[]) {
    bool visited[MAXV] = {false};
    for (int i = 0; i < G->n; i++) {
        dist[i] = INT_MAX;
        path[i] = -1;
    }
    dist[start] = 0;

    for (int i = 0; i < G->n; i++) {
        int min = INT_MAX, u = -1;
        for (int j = 0; j < G->n; j++) {
            if (!visited[j] && dist[j] < min) {
                min = dist[j];
                u = j;
            }
        }

        if

```
