## 单项选择题
1. b
2. c
3. c
4. d
5. b
6. a
7. c
8. a
9. c
## 填空题
1. (1): (n + 1) / 2         (2): 1 + α / 2
2. 哈希查找
3. 顺序存储结构（并且关键字必须有序）
4. 16
5. $\log_2 N + 1$
6. (1): O(n)       (2): $O(\log n)$          (3): $O(\sqrt{n})$
## 8.2.2 综合题
1.
![[087259bf9cd3b81cd0219094d96f036.jpg]]
2.
![[71b3a575e7fd68d8c324097c3eb4e3b.jpg]]
6.
```c
int binarySearch(int arr[], int left, int right, int target) {
    if (left > right) return -1;

    int mid = (left + right) / 2;

    if (arr[mid] == target) return mid;
    if (arr[mid] > target)
        return binarySearch(arr, left, mid - 1, target);
    else
        return binarySearch(arr, mid + 1, right, target);
}

```
9.
```c
#include <stdio.h>
#include <stdlib.h>

#define STACK_SIZE 100

typedef struct TreeNode {
    int key;
    struct TreeNode *left, *right;
} TreeNode;

typedef struct {
    TreeNode* data[STACK_SIZE];
    int top;
} Stack;

void initStack(Stack* s) {
    s->top = -1;
}

int isEmpty(Stack* s) {
    return s->top == -1;
}

int push(Stack* s, TreeNode* node) {
    if (s->top >= STACK_SIZE - 1) return 0;
    s->data[++(s->top)] = node;
    return 1;
}

TreeNode* pop(Stack* s) {
    if (isEmpty(s)) return NULL;
    return s->data[(s->top)--];
}

int isBST(TreeNode* root) {
    Stack stack;
    initStack(&stack);
    TreeNode* current = root;
    TreeNode* prev = NULL;

    while (current || !isEmpty(&stack)) {
        while (current) {
            push(&stack, current);
            current = current->left;
        }
        current = pop(&stack);
        if (prev && current->key <= prev->key)
            return 0;
        prev = current;
        current = current->right;
    }
    return 1;
}

```
12.
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct TreeNode {
    int key;
    struct TreeNode *left, *right;
} TreeNode;

#define STACK_SIZE 100

typedef struct {
    TreeNode* data[STACK_SIZE];
    int top;
} Stack;

void initStack(Stack* s) {
    s->top = -1;
}

int isEmpty(Stack* s) {
    return s->top == -1;
}

int push(Stack* s, TreeNode* node) {
    if (s->top >= STACK_SIZE - 1) return 0;
    s->data[++(s->top)] = node;
    return 1;
}

TreeNode* pop(Stack* s) {
    if (isEmpty(s)) return NULL;
    return s->data[(s->top)--];
}

void printNotLessThanX(TreeNode* root, int x) {
    Stack stack;
    initStack(&stack);
    TreeNode* current = root;

    while (current || !isEmpty(&stack)) {
        while (current) {
            push(&stack, current);
            current = current->right;
        }

        current = pop(&stack);
        if (current->key >= x) {
            printf("%d ", current->key);
            current = current->left;
        } else {
            current = NULL;
        }
    }
}

```
15.
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct TreeNode {
    int key;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

TreeNode* newNode(int key) {
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
    node->key = key;
    node->left = node->right = NULL;
    return node;
}

void inorder(TreeNode* root, int* arr, int* index) {
    if (!root) return;
    inorder(root->left, arr, index);
    arr[(*index)++] = root->key;
    inorder(root->right, arr, index);
}

void mergeArrays(int* A, int m, int* B, int n, int* C) {
    int i = 0, j = 0, k = 0;
    while (i < m && j < n) {
        C[k++] = (A[i] < B[j]) ? A[i++] : B[j++];
    }
    while (i < m) C[k++] = A[i++];
    while (j < n) C[k++] = B[j++];
}

TreeNode* sortedArrayToBST(int* arr, int left, int right) {
    if (left > right) return NULL;
    int mid = (left + right) / 2;
    TreeNode* node = newNode(arr[mid]);
    node->left = sortedArrayToBST(arr, left, mid - 1);
    node->right = sortedArrayToBST(arr, mid + 1, right);
    return node;
}

TreeNode* mergeBSTs(TreeNode* root1, TreeNode* root2) {
    int A[100], B[100], C[200];
    int n1 = 0, n2 = 0;

    inorder(root1, A, &n1);
    inorder(root2, B, &n2);
    mergeArrays(A, n1, B, n2, C);

    return sortedArrayToBST(C, 0, n1 + n2 - 1);
}

void printInOrder(TreeNode* root) {
    if (!root) return;
    printInOrder(root->left);
    printf("%d ", root->key);
    printInOrder(root->right);
}

TreeNode* insert(TreeNode* root, int key) {
    if (!root) return newNode(key);
    if (key < root->key)
        root->left = insert(root->left, key);
    else
        root->right = insert(root->right, key);
    return root;
}

int main() {
    TreeNode* root1 = NULL;
    TreeNode* root2 = NULL;

    int keys1[] = {10, 5, 15};
    int keys2[] = {20, 3, 7};

    for (int i = 0; i < 3; i++) root1 = insert(root1, keys1[i]);
    for (int i = 0; i < 3; i++) root2 = insert(root2, keys2[i]);

    TreeNode* mergedRoot = mergeBSTs(root1, root2);

    printf("合并后中序遍历结果：\n");
    printInOrder(mergedRoot); // 应输出：3 5 7 10 15 20

    return 0;
}

```
## 6.2.2 综合题 4、5、6
![[2dba400eebee9e57a1e5c679cee4579.jpg]]