## 原始指针
首先，需要牢记的是：==指针只是一个数字，一个内存地址==。

代码所做的事情，无非就是从内存中读取或是写入。指针是 c 和 c++ 当中显示联系内存的语法元素。那些所谓“没有指针”的语言，其实只是**把直接操作地址的权力封装或受控**，从而换取安全性与易用性。

在 c 和 c++ 当中：
访问内存地址我们使用 &
解引用我们使用 *
例如：
```cpp
int a = 0;      // 编译器自动分配内存来存放数字0
int* b = &a;    // 通过&我们访问到0的内存地址并赋值给b，b也是0的内存地址
*b = 1;         // 通过*解引用，将1写入b所指向的内存（也是a的内存）
cout << a << endl;
cout << b << endl;
// 最后输出的结果是：
// 1
// 1
```
这就是原始指针的全部，仅此而已。
## 内存管理
我们提到，我们代码主要是跟内存打交道，内存是至关重要的东西。我们在此简单介绍一下内存在 c++ 程序中的不同段。
广义上来说，内存可以分为文本段和数据段。
### 文本段（Text）
文本段又称为代码段，用来存放机器指令，只读。
例如 `void add(int a, int b) { return a + b;}`这一段函数在编译后就放在 Text 段。
它是固定大小的，是直接从可执行文件中读取的。
### 数据段（Data）
数据段用来存放程序中的数据，进一步可以分为静态数据和动态数据。
#### 静态数据（Static）
静态数据指的是在**编译期间就确定了存储的位置和生命周期的数据**。
静态内存细分为已初始化数据(.data)和未初始化数据(.bss)。
我在这里给出一段代码，全是静态数据并标出当中的已初始化数据和未初始化数据，你可结合这个例子来理解。
```cpp
static int a = 1;        // .data
static int b;            // .bss
int c;                   // .bss
int d = 2;               // .data

int main() {
	static int e = 3;	 // .data
	static int f;        // .bss
	return 0;
}
```

我们知道，我们没有自己初始化的时候，默认的数据是0。
这里就有一个问题，如果我想初始化为0，在此好像初始化`int a = 0；`和不初始化`int a;`效果是一样的，那么我们将静态数据拆分为已初始化和未初始化似乎没有意义。
针对这个问题，我们考虑一个极端情况：
我们拥有一个巨大的数组（一百万个数据）
1. 假设我们初始化为一百万个0`vector<int> a(1000000,0)`
   我们需要知道的是，初始化的数据是直接从可执行文件中读取的，这就使得初始化过的一百万个0要写入可执行文件中。意味着可执行文件变大，加载速度变慢。
2. 假设我们不初始化，那么BSS端只存储数组的大小，程序运行时由操作系统分配内存并默认清零。
通过这个极端的例子，我们区分.data和.bss的原因是为了节省空间和提高加载效率。
#### 动态数据（Dynamic）
动态数据分类两种不同的数据结构：堆和栈。
##### 堆（Heap）
堆的大小是可变的，可以随程序的运行而增长和收缩。作为程序员，我们可以决定它如何增长和收缩。在 c 当中，我们使用 malloc 和 free ，在 c++ 中我们使用 new 和 delete 。

在这里，我想稍微详细地讨论一下 new 和 delete。
###### new
new 的主要目的是在堆上分配内存。
根据你所写的类型，决定了要分配的内存大小。比如`new int` ，需要在内存中找到一个4字节的内存地址。
![[Pasted image 20250615224249.png]]
通过代码我们发现 new 只是一个操作符（operator），就像加减乘除一样。
通常来说 new 会去调用 malloc
`Entity* e = new Entity();` 其实约等于 `Entity* e = (Entity*)malloc(sizeof(Entity));`
但是 malloc 只分配空间，而 new 分配空间之后还会去调用构造函数。

上面所说的 new 就是我们最常用的 new ，它是 c++ 的一个==关键字==（不可重定义），实现了两步，分配内存和在该内存上构造对象。分配内存这一步调用的是 `operator new`，它是一个==函数==（可重载）；在该内存上构造对象这一步是由 `placement new` 完成的（其实 `placement new` 也是去调用的 `operator new` 的一个重载），`placement new` 允许你在指定的内存地址上构造一个对象（只构造，不分配内存）
举例说明：
```cpp
Entity* p = new Entity()；
// 上面的 new 可以写成 operator new + placement new
void* buffer = operator new(sizeof(Entity))；   // operator new 分配内存
Entity* p = new(buffer)Entity();                // placement new 在已有的buffer上构造Entity
```
###### delete
申请空间之后要记得释放空间，也就是==用完 new，要记得 delete。不然会造成内存泄漏==。
delete 是这样的：
![[Pasted image 20250615224841.png]]
delete 也是分两步的:
1. 调用对象的析构函数释放对象内部资源
2. 调用 `operator delete` 释放内存空间（`operator delete`也是一个函数，可以被重载）

需要提醒的一点是，数组调用的不是 new ，而是 new[]，我们释放的时候，调用的也不是 delete，而是delete[]。
new[]
![[Pasted image 20250715144640.png]]
delete[]
![[Pasted image 20250715144502.png]]
例如：我们 new 了一个数组`int* arr = new int[a]();`我们delete的时候就需要写`delete[] arr;
而不能写`delete arr;`
##### 栈（Stack）
栈用于存放函数的参数值、局部变量和返回地址等数据，它的工作方式类似于数据结构中的栈（后进先出，LIFO）。栈分配和释放由操作系统自动完成，不需要程序员手动申请和释放。
栈是一块连续的内存区域，最大容量一定，申请超过则会提示溢出。
### 
内存大致如此，附图便于理解。
![[Pasted image 20250616191311.png]]
## 智能指针
在 c++ 中我们使用 new 和 delete 来动态内存管理，如果我们忘记了 delete ，就内存泄漏了。避免这一情况，c++ 引入了智能指针，它能自动释放内存。
简单来说智能指针是自动实现 new 和 delete 操作的一种方式，是对原始指针的包装。
智能指针主要有：`unique_ptr`，`shared_ptr`，`weak_ptr`。
### unique_ptr
unique_ptr 是作用域指针，超出作用域时，自动调用delete进行销毁。
unique_ptr 是唯一的，**不可以复制**（假设你有两个unique_ptr，它们指向同一块内存，其中一个释放，另一个就会指向无效内存）。
你可以这样写：`unique_ptr<Entity> entity(new Entity());`
但是不能这样写：`unique_ptr<Entity> entity = new Entity();`
因为 unique_ptr 的构造函数是 explicit 的，需要显示调用构造函数，而不能进行隐式转换。
更安全的写法是：`unique_ptr<Entity> entity = make_unique<Entity>();`
### shared_ptr
多个 shared_ptr 可以共享同一块内存，当最后一个 shared_ptr 被销毁时，才会释放这一块内存。
	共享指针的工作方式是通过引用计数。（跟踪统计指针有多少引用，计数为零则删除）
	shared_ptr 会额外分配控制块，用来存储引用计数。
	强引用计数：共享同一块内存的 shared_ptr 个数。
	弱引用计数：观察这一块内存的 weak_ptr 个数。（不影响释放）
	
代码体现跟 unique_ptr 一样，依旧推荐`shared_ptr<Entity> entity = make_shared<Entity>();`

值得一提的是，unique_ptr 中不建议直接调用 new 的原因是因为异常安全，而 shared_ptr 不是。shared_ptr 会分配一块内存做控制块。如果你先 new 一个对象，然后传入 shared_ptr 的话会有两次内存分配，一是为对象分配内存，二是为控制块分配内存。但是你如果使用 make_shared ，就将两部分结合起来了，效率更高。
### weak_ptr
weak_ptr 配合着 shared_ptr 使用。使用 weak_ptr 不会获得对象的所有权，只是作为一个观察者。（可以通过weak_ptr去判断底层对象是否还活着）。
## 引用
引用只是指针的扩展，说到底==引用其实就是指针伪装的，它只是指针的语法糖==，
引用本身不是新变量，它绑定某个变量，是某个变量的别名。它不创建新的存储空间，所以并不真正占用内存。
声明引用的时候一定要初始化，也就是必须要进行绑定。
比如
```cpp
int a = 1;
int& ref = a;  // 正确

/*
	编译器会将对 ref 的所有访问都转成对 a 的访问。
	换句话说就是 ref 在编译器生成的代码中通常被替换成 a 的地址或直接操作 a 的内存。
*/
```
而不能只声明
```cpp
int& ref;
```

那引用有什么作用呢？
我们知道，值传递会导致实参的值被复制一份传递给形参，当数据大时复制开销比较明显。用指针传递则不会出现这个问题，它传递的是变量的地址，不会复制整个对象。
```cpp
void add(int* a, int* b, int* ans) {
	(*ans) = (*a) + (*b);
}

int main() {
	int x = 5, y = 6;
	int ans;
	add(&x, &y, &ans);
	cout << ans << endl;
}
```
上面的 & 和 * 略显麻烦，我们说过引用是指针的语法糖，它就可以让传递显得更清爽。
例如上面的代码就等价于：
```cpp
void add(int& a, int& b, int& ans) {
	ans = a + b;
}

int main() {
	int x = 5, y = 6;
	int ans;
	add(x, y, ans);
	cout << ans << endl;
}
```
## 总结
指针只是一个数字，一个内存地址。
便于动态内存管理，c++ 引入了智能指针，自动释放内存。
而引用则只是指针的语法糖，允许别名访问，语法上跟直观。
接下来是叠甲时间：
因为是个人学习笔记，所述定然不够详细，见谅。
小生只是一名在校的学生，初学c++，定会有错误和疏漏，请各位前辈批评指正。若各位前辈能留言建议，将不胜感激。