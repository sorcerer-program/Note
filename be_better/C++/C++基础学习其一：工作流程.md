---
date: 2025-06-11
tags:
  - 基础学习
  - cpp
---
# C++的工作流程
C++的整体构建过程主要过程可以粗浅地理解为两步：**编译和链接**。
源代码经过编译器得到一个一个 .obj 文件，链接器将一个一个 .obj 文件缝成一个 .exe 文件。
## 编译（Compiling）
源代码正式进入编译器前，会做一些文本级的处理，这个过程是预处理。
### 预处理
预处理基本上是对以 `#` 开头的预处理指令的处理，可以看做是编译前的“文本替换”阶段。（同时还会删除注释）
写代码时最常见的有：`#include`  `#pragma once`
##### \#include
`#include` 本质是将一个文件的内容插入到当前位置，就像复制粘贴一样。比如 `#include <iostream>` 和 `#include "head.h"` ，其实就是去找到对应的头文件，把它copy过来。
这里我们可以举一个很有意思的例子：
首先写一个 head.h 文件
```cpp
}
```
然后是一个 main.cpp 文件
```cpp
#include <iostream>
int main(){
	std::cout << "Hello World" << std::endl;
#include "head.h"
```
意外的是，这是没问题的。

关于 `#include`，`<>` 和 `" "` 则是老生常谈问题。 
它们都用于包含头文件，但查找路径的顺序不同。
<> 于包含标准库或是第三方库的头文件，编译器只在系统默认的头文件夹路径中查找（比如
/user/include/ 或者是 vs 的 sdk）；
" "用于包含用户自定义的头文件，编译器优在当前源文件的目录中查找，找不到再去系统
路径查找。
通常写代码时顺序先 <> 标准库，在 <> 第三方库，最后 " " 自己头文件。
##### \#pragma once
头文件中通常有 `pragma once`来避免重复包含。
我们自然不会傻到在同一个cpp文件当中写多次次一模一样的include。但是当项目复杂，头文件之间彼此依赖，可就说不准了，因为会存在一个间接引用问题。
比如：a 引用 c，b 引用 a和c，此时 b 就 include "c.h" 两次，可能引发类型多次定义的编译错误。
### 正式编译
预处理之后就将进入编译阶段，过程是十分复杂的，主要步骤如图所示：

![[Pasted image 20250612191825.png]]
此文为c++学习记录，对具体编译不做扩展，粗略介绍如下：
1. ==词法分析==：词法分析阶段将源代码字符流分割成一个一个有意义的词法单元(Token)：关键字、标识符、运算符、常量等等，得到一个Token序列（每个Token都有一个类别和具体的值），为语法分析做准备。
2. ==语法分析==：语法分析根据语法规则将Token序列组织成一颗语法树(Parse Tree)，然后进一步构建出抽象语法树(AST)。它检查代码是否**结构上合法**，并构建出结构化的表达。
   (备注：实际编译器实现中，很多解析器会直接跳过具体语法树，直接生成抽象语法树)
3. ==语义分析==：语义分析确保程序在**逻辑上是合理**的，比如变量是否已经声明、类型是否匹配、函数调用是否正确等。语义分析的输入是抽象语法树（通过语法分析生成的）；通过时输出带有语义标注（包含完整的类型信息，符号绑定信息，作用域信息等）的 AST，失败时抛出语义错误。
4. ==生成中间代码==：语义分析通过后，抽象语法树会转化为只在编译器内部使用的中间代码（IR），这样是为了支持多种编程语言或者机器语言。
5. ==优化==：这一步，编译器将利用各种优化技术（常量折叠、死代码消除、循环优化等）对中间代码进行优化。以提高最终代码的效率和质量。
6. ==目标代码生成==：代码生成器将中间代码转化为目标代码（.obj）。
   (备注：其实编译之后拿到的是 .s 文件还需要通过汇编器得到 .obj，此处粗浅将此归到编译)

有意思的是，编译通过并不代表正确，因为编译器相信我们的鬼话。它就像个“语法检查器”，能发现“句子是否合乎语法”，但无法判断“这句话是否说谎”。
比如，我们大言不惭地在前面声明了一个函数 `void print(char* msg);` 但是我们有没有写这个函数定义。编译的时候是可以通过的，但是链接的时候会报错。
### 编译总结
编译会创建抽象语法树（说到底编译器的工作就是把代码转化成要么是 constant data 常数资料，要么是 instructions 指令），经过 AST 进而产生 CPU 会执行的机器码。
## 链接（Linking）
链接的核心任务是**解析符号引用**。通俗点讲就是找到每个符号和函数的位置，并将它们链接在一起。
假设我们写了多个源文件：
* `main.cpp` 声明了 `int add(int a, int b);` ，但是没有实现。
* `main.cpp` 调用了 `math.cpp` 当中的 `add()` 函数。
在编译的时候：
* `main.cpp` --> `main.obj` （包含 `add()` 的调用，但是不知道它的实现）
* `math.cpp` --> `math.obj` （包含 `add()` 的实现）
这个时候 `main.obj` 不知道 `add()`在哪，无法运行。通过链接器，把 `main.obj` 和 `math.obj` 合并（缝合成一个可执行文件，比如.exe或者.out或者动态库），就能够让 `main` 找到 `add()` 。

值得一提的是，链接器确定程序的入口，是通过链接脚本或是编译器运行时库决定的。所以通过合理的设置，你的`main`不一定叫 `main`，叫做 `mian` 也不是不行。
## 结语
c++通过**编译**将源代码转换为机器码（目标文件），再通过**链接**将多个目标文件和库合并生成最终可执行程序。
下面是叠甲时间：
本文只为理解C++的工作流程，编译和链接是复杂的过程，详尽内容未有解释，见谅。
小生只是一名在校的学生，初学c++，定会有错误和疏漏，请各位前辈批评指正。若各位前辈能留言建议，将不胜感激。