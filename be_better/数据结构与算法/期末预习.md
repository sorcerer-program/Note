
入队
```c
void queueAppend(queueList* ql, eletype x){
	queueNode* temp = (queueNode*)malloc(sizeof(queueNode));
	temp->data = x;
	temp->next = NULL;
	if (ql->front == NULL){
		ql->front = temp;
		ql->rear = temp;
	}else{
		ql->rear->next = temp;
		ql->rear = temp;
	}
}
```
出队
```c
eletype queueEle(queueList* ql){
	if (ql->front == NULL) return NULL;
	queueNode* temp = ql->front;
	eletype x = temp->data;
	if (ql->front == ql->rear){
		ql->front = NULL;
		ql->rear = NULL;
	}else{
		ql->front = ql->front->next;
	}
	free(temp);
	return x;	
}
```

实现尾插法创建带头节点的单链表
```c
LNode* create_back(){
	LNode* head, tail, p;
	head = (LNode*)malloc(sizeof(LNode));
	head->next = NULL;
	tail = head;
	eletype x;
	while(1){
		printf("请输入要插入的数据：");
		scanf("%d", &x);
		if (x == 0) break;
		p = (LNode*)malloc(sizeof(LNode));
		p->data = x;
		p->next = NULL;
		tail->next =  p;
		tail = p;
	}
	return head;
}
```

实现头插法创建带头结点的单链表
```c
LNode* create_front(){
	LNode* head, tail, p;
	head = (LNode*)malloc(sizeof(LNode));
	head->next = NULL;
	eletype x;
	while(1){
		printf("请输入要插入的数据：");
		scanf("%d", &x);
		if (x == 0) break;
		p = (LNode*)malloc(sizeof(LNode));
		p->data = x;
		p->next = head->next;
		head->next = p;
	}
	return head;
}
```
编写一个函数 int del(LNode* head, int n)，head指向头结点，实现删除单链表head的第n个节点，成功1，失败0
```c
int del(LNode* head, int n){
	if (n <= 0 || head == NULL) return 0;
	LNode* p = head;
	int i = 0;
	while(p->next){
		i++;
		if (i != n) continue;
		LNode* temp = p->next;
		p->next = p->next->next;
		free(temp);
		return 1;
	}
	return 0;
}
```

1. 下列说法==不正确==的是(D)

	A. ==数据元素是数据的基本单位==  
	
	B. 数据项是数据中不可分割的最小可标识单位
	
	C. 数据可由若干个数据元素构成
	
	D. 数据项可由若干个数据元素构成

	数据（Data）
	│
	├── 数据对象（Data Object）：一类数据元素的集合（如学生集合）
	│
	├── 数据元素（Element）：具有一定意义的整体单位（如一个学生）
	│
	└── 数据项（Item）：构成数据元素的最小单位（如学号、姓名、性别）

2. 若线性表最常用的运算是存取第i个元素及其前驱的值，则采用(D)存储方式效率最高。

	A. 单链表         B. 双链表            C. 单循环链表          D. 顺序表

- **线性表的存储结构：**
    
    - **顺序表**：元素在内存中**连续存储**，支持**随机访问**（即直接访问第 i 个元素，时间复杂度为 O(1)）。
        
    - **链表**：
        
        - **单链表**：每个节点只存储一个后继指针，无法快速访问前驱节点。
            
        - **双链表**：每个节点存储前驱和后继指针，访问某节点的前驱较方便，但访问第 i 个节点仍需遍历。
            
        - **循环链表**：首尾相连，适合循环处理，但不支持快速按序号访问。
            
- **访问效率分析：**
    
    - **顺序表**：
        
        - 访问第 i 个元素：**O(1)**
            
        - 访问前驱（第 i-1 个元素）：**O(1)**
            
    - **链表类结构**：
        
        - 访问第 i 个元素：**O(n)**（需从头开始遍历）
            
        - 访问前驱：对于单链表是 **O(n)**，双链表是 **O(1)**（如果已知当前位置）